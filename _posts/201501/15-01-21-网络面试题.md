---
layout: post
title: 网络面试题(1)
description: 网络部分的面试题
categories:
- Job
tags:
- Interview
---

###TCP三次握手及四次挥手
- 三次握手

1. 第一次握手

	客户端向服务器发送一个 SYN J

2. 第二次握手

    服务器向客户端响应一个 SYN K, 并对 SYN J 进行确认 ACK J + 1

3. 第三次握手

	客户端再向服务器发送一个确认 ACK K + 1

	序列图:

    ![15_01_21_1][15_01_21_1]

	图解:

    从该序列图中可以看出, 当客户端调用 connect 时, 触发了一个连接请求, 向服务器发送了 SYN J 包, 这时 connect 进入了阻塞状态; 服务器监听到链接请求, 即收到 SYN J 包, 调用 accept 函数接收请求向客户端发送 SYN K, ACK J + 1, 这时 accept 进入阻塞状态; 客户端收到服务器的 SYN K, ACK J + 1 之后, 这时 connect 返回, 并对 SYN K 进行确认; 服务器收到 ACK K + 1时, accept 返回, 至此三次握手完毕, 连接建立.

- 四次挥手(TCP连接全双工)

1. 客户端向服务器发送一个 FIN M

2. 服务器向客户端响应一个 ACK M + 1

3. 服务器向客户端发送一个 FIN N

4. 客户端响应返回一个ACK N + 1

	序列图:

     ![15_01_21_2][15_01_21_2]

     图解:

     + 某个应用进程首先调用 close 主动关闭连接, 这时 TCP 发送一个 FIN M;
     + 另一端接收到 FIN M 之后, 执行被关闭, 对这个 FIN 进行确认. 它的接收也作为文件结束符传递给应用进程, 因为FIN的接受意味着应用进程在相应的连接上再也接收不到额外数据;
     + 一段时间后, 接收到文件结束符的应用进程调用 close 关闭它的 socket. 这导致它的 TCP 也发送一个 FIN N;
     + 接收到这个 FIN 的源发送端 TCP 对它进行确认.


-----

###网络层次

- 因特网协议栈

	1. 应用层

	支持网络应用, 应用协议仅仅是网络应用的一个组成部分, 运行在不同主机上的进程则使用应用层协议进行通信. 主要的协议有: HTTP, FTP, TELNET, SMTP, POP3等;

	2. 传输层

	负责为信源和星宿提供应用程序进程间的数据传输服务, 这一层主要定义两个传输协议, 传输控制协议即TCP和用户数据报协议UDP.

	3. 网络层

	负责将数据报独立地从信源发送个星宿, 主要解决路由选择, 拥塞控制和网络互联等问题.

	4. 数据链路层

	负责将IP数据报封装成合适在物理网络上传输的帧格式并传输, 或将从物理网络接收到的帧解封, 取出IP数据报交给数据层.

	5. 物理层

	负责将比特流在结点间传输, 即负责物理传输. 该层的协议既与链路有关也与传输介质有关.

- OSI模型

	1. 物理层

	物理层是参考模型的最底层, 这层是网络通信的数据**传输介质**, 由连接不用结点的电缆与设备共同构成, 主要功能是: 利用传输介质为数据链路层提供物理连接, 负责处理数据传输并监控数据出错率, 以便数据流的**透明传输**, 网线, 信鸽都属于第一层范畴.

	2. 数据链路层

	数据链路层是参考模型的第二层, 主要功能是: 在物理层提供的服务基础上, 在通信的实体间建立数据链路连接, 传输以"帧"为单位的数据包, 并采用**差错控制**与**流量控制**方法, 使有差错的物理线路变成无差错的数据链路, MAC地址, 交换机或者网卡和驱动程序都属于第二层范畴.

	3. 网络层

	网络层是参考模型的第三层, 主要功能有: 为数据在结点之间传输创建逻辑链路, 通过**路由选择算法**为分组通过通信子网选择最适当的路径, 以及实现**拥塞控制**, **网络互联**等功能, IP地址, 路由协议和地址解析协议(ARP)都数据第三层范畴.

	4. 传输层
	传输层是参考模型的第四层, 主要功能是向用户提供可靠的端到端服务, 处理数据包错误, 数据包次序, 以及其他一些关键传输问题. 传输层向高层屏蔽了下层数据通信的细节, 因此他是计算机通信体系结构中关键的一层, TCP(数据段), UDP(数据报).

	5. 会话层

	会话层是参考模型的第五层, 主要功能是: 负责维护两个结点之间的传输链接, 以便确保点到点传输不中断, 以及管理数据交换等功能.

	6. 表示层

	表示层是参考模型的第六层, 主要功能是: 用户处理在两个通信系统中交换信息的表示方式, 主要包括数据格式转换, 数据加密与解密, 数据压缩与恢复等功能.

	7. 应用层

	应用层是参考模型的第七层, 主要功能是: 为应用软件提供了很多服务, 例如文件服务器, 数据库服务, 电子邮件与其他网络软件服务.


-----

###网络编程模型

- 同步阻塞

	最常用的一个模型, 在这个模型中, 用户空间的引用程序执行一个系统调用, 这回导致应用程序的阻塞. 这意味着应用程序会一直阻塞, 直到系统调用完成为止(数据参数完成或发生错误). 调用引用程序处于一种不再消费CPU而只是简单的等待响应的状态, 因此从处理的角度来看, 这是非常有效的

	典型序列图(读操作)

	![15_01_21_3][15_01_21_3]

	在调用Read()方法时, 应用程序会阻塞并对内核进行上下文切换. 然后会触发读操作, 当响应返回时(从我们正在从中读取的设备中返回), 数据就被移动到用户空间的缓冲区中. 然后应用程序就会解除阻塞(Read() 方法调用返回).
	从应用程序的角度来说, Read() 调用会延续很长时间. 实际上, 在内核执行读操作或其他工作时, 引用程序的确会被阻塞.

- 同步非阻塞 I/O

	同步阻塞I/O的一种效率稍低的变种是同步非阻塞 I/O. 在这种模型中, 设备是以非阻塞的形式打开的. 这意味着 I/O 操作不会立即完成也很, Read() 操作可能会返回一个错误代码, 说明这个命令不能立即满足(EAGAIN 或 EWOULDBLOCK).

	典型序列图(读操作)

	![15_01_21_4][15_01_21_4]

	非阻塞的实现是 I/O 命令可能并不会立即满足, 需要应用程序调用许多次来等待操作完成. 这可能效率不高, 因为很多情况下, 当内核执行这个命令时, 应用程序必须要进行忙碌等待, 直到数据可用为止, 或者试图执行其他工作. 这个方法可以引入 I/O 操作的延时, 因为数据在内核中变为可用到用户调用Read返回数据之间存在一定的间隔, 这会导致整体数据吞吐量的降低.

- 异步阻塞 I/O

	带有阻塞通知的非阻塞 I/O, 模型中, 配置的是非阻塞 I/O, 然后使用 Select 系统调用来确定一个 I/O 描述符何时有操作. 使 Select 调用非常有趣的是他可用用来为多个描述符提供通知, 而不仅仅一个描述符提供通知. 对于每个提示符来说, 我们可以请求这个描述符可以写数据, 有读数据可用以及是否发生错误的通知.

	典型序列图(读操作)

	![15_01_21_5][15_01_21_5]

	Select() 调用的主要问题是它的效率不是非常高, 尽管这是异步通知使用的一种方便模型, 但是对于高性能的 I/O 操作来说不建议使用.

- 异步非阻塞 I/O

	异步非阻塞 I/O 模型是一种处理与 I/O 重叠进行的模型. 读请求会立即返回, 说明 Read() 请求已经成功发起了. 在后台完成读操作时, 应用程序然后会执行其他操作. 当 Read() 的响应到达时, 就会产生一个信号或执行一个基于线程的回调函数来完成这次 I/O 处理过程.

	典型序列图(读操作)

	![15_01_21_6][15_01_21_6]

	在一个进程总为了执行多个 I/O 请求而对计算操作和 I/O 处理进行重叠处理的能力利用了处理速度和 I/O 速度之间的差异. 当一个或多个 I/O 请求挂起时, CPU执行其他任务; 或者更为常见的是, 再发起其他 I/O 的同时对已经完成的 I/O 进行操作.






[15_01_21_1]:http://7u2ntw.com1.z0.glb.clouddn.com/job/15_01_21_1.png
[15_01_21_2]:http://7u2ntw.com1.z0.glb.clouddn.com/job/15_01_21_2.png
[15_01_21_3]:http://7u2ntw.com1.z0.glb.clouddn.com/job/15_01_21_3.png
[15_01_21_4]:http://7u2ntw.com1.z0.glb.clouddn.com/job/15_01_21_4.png
[15_01_21_5]:http://7u2ntw.com1.z0.glb.clouddn.com/job/15_01_21_5.png
[15_01_21_6]:http://7u2ntw.com1.z0.glb.clouddn.com/job/15_01_21_6.png